# Резюме

Этот репозиторий содержит дополнительный код и данные для курсовой работы "Improving Attacks on Round-Reduced Speck32/64 Using Deep Learning". В частности, он включает:

- реализацию концепта атаки на 11 раундов для Speck32/64 (test_key_recovery.py), с параметрами для практической атаки на 12 раундов в конце кода,
- базовый скрипт для обучения, который обучает нейронную сеть с 10 блоками для различения 5-раундового Speck от случайных данных с использованием описанного в курсовой работе основного конвейера обучения (train_5_rounds.py),
- заранее обученные нейронные различители для 5, 6, 7 и 8 раундов Speck,
- реализацию концепта поиска различий входных данных с использованием подхода few-shot learning (neural_difference_search.py),
- скрипт для оценки заранее обученных нейронных различителей как в реальной против случайной настройке, так и в реальных различиях, описанных в разделе 5 курсовой работы (eval.py),
- скрипт (key_rank.py), который вычисляет статистику ранга ключа для атаки на 9 раундов курсовой работы с нейронным различителем, когда доступно от 32 до 128 пар шифротекстов,
- еще один скрипт (key_rank_ddt.py), который реализует тот же эксперимент, используя различители на основе DDT,
- программу на Python, которая проверяет, зависит ли производительность нейронного различителя для 7 раундов от ключа (key_nonuniformity.py),
- скрипт на Python, который реализует алгоритм KeyAveraging из курсовой работы,
- программу на C++ (speck.cpp в подкаталоге cpp), которая позволяет проверить различные утверждения курсовой работы о распределении различий для 5-раундового Speck, мощности различителей на основе поиска ключа, вероятности наиболее вероятного дифференциального перехода для 8-раундового Speck и свойства конкретных выходных пар, найденных в курсовой работе, при скромном вычислительном бюджете (менее одного дня на стандартном ПК),
- программу на C++ (speck_ddt.cpp в подкаталоге cpp), которая вычисляет распределение различий для до 8 раундов Speck32/64 с заданным входным различием 0x0040/0000 и записывает результаты на диск. Для этого требуется машина с примерно 70 ГБ свободной оперативной памяти и около 300 дней вычислительного времени на ЦПУ. Она будет вычислять предсказанные распределения выходных данных для каждого раунда последовательно и записывать результат на диск; эти файлы занимают около 35 ГБ каждый. Полученные файлы можно загрузить в Python-среду, вызвав numpy.fromfile(filename), и полученные массивы можно использовать в key_rank_ddt.py для проведения атаки на 9 раундов с использованием таблицы распределений различий.

Этот архив также содержит предварительно вычисленные данные для ранга ключа для атаки на 9 раундов (подкаталог data_9r_attack), данные о зависимости ключа для различителя на 7 раундов, полную историю обучения нашего лучшего нейронного различителя для 5 раундов (как указано в курсовой работе) и профили откликов для неверных ключей для всех предоставленных предварительно обученных нейронных сетей, кроме 5-раундовой. История обучения 5-раундовой сети, описанная в курсовой работе, хранится как сериализованный словарь в подкаталоге supplementary data.

#  Зависимости и системные требования

Предоставленные Python модули зависят друг от друга. Для выполнения экспериментов скачайте полный архив.

Требования для запуска основной атаки: Python 3.7.12, текущая установка keras, h5py. Тестировалось с использованием backend tensorflow, но код должен работать с любым backend. Требования для кода обучения и оценки те же. Проверенная конфигурация: keras 2.1.5, tensorflow 1.6.0, h5py 2.7.1.

Демонстратор нейронного поиска различий дополнительно требует установки текущей версии scikit-learn. Проверенная версия: scikit-learn 0.19.1.

Программы на C++ должны работать с любой версией g++, поддерживающей C++2014. Тестировалась версия g++7.3. Код использует встроенные функции gcc, поэтому другие компиляторы не будут работать без изменений в коде.

Все программы в этом репозитории (за исключением, возможно, скриптов для расчета ранга ключа и DDT) должны работать нормально на стандартном ПК. В частности, код атаки на 11 раундов должен работать достаточно быстро без поддержки GPU.

#  Компиляция cpp-файлов

Чтобы собрать программы на C++, выполните команду make в подкаталоге cpp. Это создаст два исполнимых файла:

- speck_analysis: выполняет ряд экспериментов, которые будут подтверждать правильность различных утверждений в курсовой работе (вычислительный бюджет — около одного дня на стандартном ПК).
- speck_ddt: вычисляет распределение различий для Speck с входным различием, использованным в курсовой работе. Для этого требуется значительный объем памяти, дискового пространства и вычислительной мощности.

#  Запуск экспериментов

Каждый из упомянутых Python файлов содержит скрипт, который будет выполнять определенную серию экспериментов при запуске из терминала с использованием python3.

Инструкции для каждого из экспериментов:

1. **test_key_recovery.py**: запустите из терминала с командой _python3 test_key_recovery.py_.

   Обратите внимание, что это выполнит атаку на 11 раундов 100 раз, а затем проведет атаку на 12 раундов (не описанную в курсовой работе, но использующую тот же код) 20 раз. Это займет некоторое время, если только не доступен быстрый GPU (одна попытка атаки на 12 раундов займет примерно 12 часов на ПК с четырьмя ядрами без GPU). Обратите внимание, что атака на 12 раундов с этими настройками успешна только в 40% случаев, поэтому одной попытки может быть недостаточно для демонстрации её работы. Удалите несколько последних строк в скрипте, чтобы отключить атаку на 12 раундов.

   Атака на 11 раундов создаст три файла, содержащие массивы numpy с следующей информацией:

   - run_sols1.npy содержит битовое различие между реальным под-ключом и лучшим предположением для последнего под-ключа для каждой попытки.
   - run_sols2.npy содержит битовое различие между реальным под-ключом и лучшим предположением для предпоследнего под-ключа для каждой попытки.
   - run_good.npy записывает максимальное количество хороших переходов начального дифференциала для всех использованных шифротекстов в каждой попытке. Эта информация предназначена для демонстрации, какие попытки теоретически можно решить с использованием методов, описанных в курсовой работе.

   Во время выполнения скрипт будет показывать, сколько тестов завершено. Для каждого завершенного теста также будет показываться битовое различие между окончательными предположениями последних двух под-ключей и реальными под-ключами.

   В конце выполнения будет выведена информация о среднем времени выполнения атаки и объеме используемых данных.

2. **eval.py**: запустите из терминала с *python3 eval.py*. Результаты должны быть самопоясняющимися.

3. **train_5_rounds.py**: запустите из терминала с *python3 train_5_rounds.py*. Данные будут записаны в подкаталог ./freshly_trained_networks/.

4. **speck.cpp**: компилируйте согласно инструкции выше и запустите полученный исполнимый файл speck_analysis из терминала. Вывод должен быть самопоясняющимся. Полученный CSV файл можно прочитать с помощью функции readcsv из модуля Python, реализующего Speck. После этого можно сравнить предсказания, сделанные с помощью модели Маркова, с предсказаниями, полученными, например, с использованием заранее обученной нейронной сети для 5 раундов, включенной в этот репозиторий.

5. **neural_difference_search.py**: запустите из терминала с *python3 neural_difference_search.py*. Сначала будет обучен новый различитель для 3 раундов для Speck с случайным входным различием, а затем этот различитель будет использован с методом few-shot learning и общим алгоритмом оптимизации, описанным в курсовой работе, для поиска входных различий, которые могут быть более эффективно различимы. Прогресс (эффективность различителя для трех раундов, расширения на большее количество раундов, входное различие) будет показываться каждый раз, когда будет найдено улучшение. Поиск будет перезапущен десять раз для получения выборки возможных результатов алгоритма.

6. **key_rank.py**: генерирует статистику ранга ключа для простой атаки на 9 раундов на Speck32/64 с использованием нейронного различителя.

7. **key_rank_ddt.py**: использует функцию stats_key_rank для выполнения того же, что и предыдущий скрипт, но с использованием таблицы распределения различий. DDT необходимо загрузить отдельно.

8. **key_averaging.py**: реализует KeyAveraging и создание высококачественных обучающих данных с использованием вывода из KeyAveraging.

#  Заключительные замечания

Включенные в этот каталог предварительно обученные сети — это небольшие сети с одним резидуальным блоком. Поэтому их предсказательная способность для пяти и шести раундов несколько ниже, чем заявлено в курсовой работе. Запустите скрипт обучения для пяти раундов, чтобы получить различитель для пяти раундов с производительностью, указанной в курсовой работе.

